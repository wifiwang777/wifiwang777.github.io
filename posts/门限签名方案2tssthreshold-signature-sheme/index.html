<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>门限签名方案2——TSS(threshold-signature-sheme) | 伍伍爹</title>
<meta name=keywords content><meta name=description content="背景 目前市面上流行的门限椭圆曲线数字签名（Threshold ECDSA）方案是由Rosario Gennaro and Steven Goldfeder在2018年发布的论文（简称gg18）为理论基础实现的，本文主要描述了gg18在ECDSA中的大致流程。
链接 Multiparty Threshold ECDSA (GG18)
http://aandds.com/blog/multiparty-threshold-ecdsa.html
gg18.pdf gg20.pdf
TSS过程 密钥生成 假设现在有个T-N等于2-3的tss方案，参与者为a,b,c; 1、a,b,c分别各选择一个随机数为自己的秘密值,如，Sa = 1 ,Sb = 2, Sc = 3， 整体的秘密（私钥d）=Sa + Sb +Sc = 1 + 2 + 3 =6; 2、用各自选择的秘密值，再随机各生成一个(T-1)次的多项式，如： Fn_a = x + 1 Fn_b = 2x + 2 Fn_c = 3x + 3 3、将各自的秘密值分享给其他参与者 假设a的id为1，b的id为2，c的id为3，将各自的id分享给参与者 a，b，c使用自己的多项式方程将其他人的id带入其中 a: Fn_a(1) = 2 #a自己留存 Fn_a(2) = 3 #发送给b Fn_a(3) = 4 #发送给c b: Fn_b(1) = 4 #发送给a Fn_b(2) = 6 #b自己留存 Fn_b(3) = 8 #发送给c c: Fn_c(1) = 6 #发送给a Fn_c(2) = 9 #发送给b Fn_c(3) = 12 #c自己留存 4、a，b，c分别计算他们的Xi X_a = Fn_a(1) + Fn_b(1) + Fn_c(1) = 2 + 4 + 6 = 12 #a计算并保存 X_b = Fn_a(2) + Fn_b(2) + Fn_c(2) = 3 + 6 + 9 = 18 #b计算并保存 X_c = Fn_a(3) + Fn_b(3) + Fn_c(3) = 4 + 8 + 12 = 24 #c计算并保存 至此，私钥&#34;6&#34;已经通过2-3的方式分散到了a,b,c三个参与者中，也就是说，(1,12),(2,18),(3,24)这三个点， 其中任意两个点都可以通过拉格朗日插值算法，得到x=0处的值就是秘密值&#34;6&#34;。 此时a的碎片值就是&#34;12&#34; 此时b的碎片值就是&#34;18&#34; 此时c的碎片值就是&#34;24&#34; 那么公钥如何产生呢？ a,b,c分别计算Sa*G、Sb*G、Sc*G然后分享给其他人（不会泄漏各自的秘密值）， 最终每个人都能得到Sa*G、Sb*G、Sc*G。 然后计算Sa*G+Sb*G+Sc*G=(Sa+Sb+Sc)*G=d*G=Q,就能得到公钥了。 签名 思路 求r 现在a，b要进行签名 R(x,y)=k^-1 * G (mod n),r=x。 注: 1、此处k^-1表示为k对于n（椭圆曲线的阶）的取模逆元，即找到一个数z，令k*z ≡ 1 (mod n) ,k^-1 = z 2、此处的k的含义跟普通ECDSA签名算法里面的k并不是一个概念，但是能满足签名和验签公式，因为满足k*k^-1=1 引入一个变量γ，γ=∑γ_i R = k^-1 * γ * γ^-1 * G = (kγ)^-1 * γG = (kγ)^-1 * (γ_a +γ_b)G = (kγ)^-1 * (γ_a*G + γ_b*G) 每个参与者单独计算γi*G,这个可以公开，因为γi*G反推不出γi。 然后就是想个办法计算σ=k*γ了 求s s = k(m+dr) =(k_a + k_b)m + kdr =(k_a + k_b)m + ∂*r =(k_a + k_b)m + (∂_a + ∂_b)*r =(k_a*m + ∂_a*r) + (k_b*m + ∂_b*r) 引入变量∂，令k*d=∂=∑∂_i 签名步骤 由上面密钥生成的步骤可得，a的碎片x_a为12，b的碎片x_b为18。 它们是私钥&#34;6&#34;的(2,3)Feldman-VSS分享方案。 我们先它变为整体秘密&#34;6&#34;的2人additive sharing分享方案。 即要满足 d_a + d_b = 6 ，通过拉格朗日系数相乘方法可以求得： d_a = µ_a * x_a = [(0-2)/(1-2)] * x_a = 2 * x_a = 24 d_b = µ_b * x_b = [(0-1)/(2-1)] * x_b = -1 * x_b = -18 显然满足d_a + d_b = 24 - 18 = 6 1、a，b随机选择k_i、γ_i,如： k_a,k_b γ_a,γ_b Ps：k_i,γ_i自始自终都不会直接分享出去 定义k = k_a + k_b 定义γ = γ_a + γ_b 2、每两个人都进行两次MtA(Multiplicative-to-Additive)协议 2."><meta name=author content><link rel=canonical href=https://wifiwang777.github.io/posts/%E9%97%A8%E9%99%90%E7%AD%BE%E5%90%8D%E6%96%B9%E6%A1%882tssthreshold-signature-sheme/><link crossorigin=anonymous href=/assets/css/stylesheet.2d50b1531bd1b3146d65c5543bd298f7f982786aadee4c223cb3a1cb51906106.css integrity="sha256-LVCxUxvRsxRtZcVUO9KY9/mCeGqt7kwiPLOhy1GQYQY=" rel="preload stylesheet" as=style><link rel=icon href=https://wifiwang777.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://wifiwang777.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://wifiwang777.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://wifiwang777.github.io/apple-touch-icon.png><link rel=mask-icon href=https://wifiwang777.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="门限签名方案2——TSS(threshold-signature-sheme)"><meta property="og:description" content="背景 目前市面上流行的门限椭圆曲线数字签名（Threshold ECDSA）方案是由Rosario Gennaro and Steven Goldfeder在2018年发布的论文（简称gg18）为理论基础实现的，本文主要描述了gg18在ECDSA中的大致流程。
链接 Multiparty Threshold ECDSA (GG18)
http://aandds.com/blog/multiparty-threshold-ecdsa.html
gg18.pdf gg20.pdf
TSS过程 密钥生成 假设现在有个T-N等于2-3的tss方案，参与者为a,b,c; 1、a,b,c分别各选择一个随机数为自己的秘密值,如，Sa = 1 ,Sb = 2, Sc = 3， 整体的秘密（私钥d）=Sa + Sb +Sc = 1 + 2 + 3 =6; 2、用各自选择的秘密值，再随机各生成一个(T-1)次的多项式，如： Fn_a = x + 1 Fn_b = 2x + 2 Fn_c = 3x + 3 3、将各自的秘密值分享给其他参与者 假设a的id为1，b的id为2，c的id为3，将各自的id分享给参与者 a，b，c使用自己的多项式方程将其他人的id带入其中 a: Fn_a(1) = 2 #a自己留存 Fn_a(2) = 3 #发送给b Fn_a(3) = 4 #发送给c b: Fn_b(1) = 4 #发送给a Fn_b(2) = 6 #b自己留存 Fn_b(3) = 8 #发送给c c: Fn_c(1) = 6 #发送给a Fn_c(2) = 9 #发送给b Fn_c(3) = 12 #c自己留存 4、a，b，c分别计算他们的Xi X_a = Fn_a(1) + Fn_b(1) + Fn_c(1) = 2 + 4 + 6 = 12 #a计算并保存 X_b = Fn_a(2) + Fn_b(2) + Fn_c(2) = 3 + 6 + 9 = 18 #b计算并保存 X_c = Fn_a(3) + Fn_b(3) + Fn_c(3) = 4 + 8 + 12 = 24 #c计算并保存 至此，私钥&#34;6&#34;已经通过2-3的方式分散到了a,b,c三个参与者中，也就是说，(1,12),(2,18),(3,24)这三个点， 其中任意两个点都可以通过拉格朗日插值算法，得到x=0处的值就是秘密值&#34;6&#34;。 此时a的碎片值就是&#34;12&#34; 此时b的碎片值就是&#34;18&#34; 此时c的碎片值就是&#34;24&#34; 那么公钥如何产生呢？ a,b,c分别计算Sa*G、Sb*G、Sc*G然后分享给其他人（不会泄漏各自的秘密值）， 最终每个人都能得到Sa*G、Sb*G、Sc*G。 然后计算Sa*G+Sb*G+Sc*G=(Sa+Sb+Sc)*G=d*G=Q,就能得到公钥了。 签名 思路 求r 现在a，b要进行签名 R(x,y)=k^-1 * G (mod n),r=x。 注: 1、此处k^-1表示为k对于n（椭圆曲线的阶）的取模逆元，即找到一个数z，令k*z ≡ 1 (mod n) ,k^-1 = z 2、此处的k的含义跟普通ECDSA签名算法里面的k并不是一个概念，但是能满足签名和验签公式，因为满足k*k^-1=1 引入一个变量γ，γ=∑γ_i R = k^-1 * γ * γ^-1 * G = (kγ)^-1 * γG = (kγ)^-1 * (γ_a +γ_b)G = (kγ)^-1 * (γ_a*G + γ_b*G) 每个参与者单独计算γi*G,这个可以公开，因为γi*G反推不出γi。 然后就是想个办法计算σ=k*γ了 求s s = k(m+dr) =(k_a + k_b)m + kdr =(k_a + k_b)m + ∂*r =(k_a + k_b)m + (∂_a + ∂_b)*r =(k_a*m + ∂_a*r) + (k_b*m + ∂_b*r) 引入变量∂，令k*d=∂=∑∂_i 签名步骤 由上面密钥生成的步骤可得，a的碎片x_a为12，b的碎片x_b为18。 它们是私钥&#34;6&#34;的(2,3)Feldman-VSS分享方案。 我们先它变为整体秘密&#34;6&#34;的2人additive sharing分享方案。 即要满足 d_a + d_b = 6 ，通过拉格朗日系数相乘方法可以求得： d_a = µ_a * x_a = [(0-2)/(1-2)] * x_a = 2 * x_a = 24 d_b = µ_b * x_b = [(0-1)/(2-1)] * x_b = -1 * x_b = -18 显然满足d_a + d_b = 24 - 18 = 6 1、a，b随机选择k_i、γ_i,如： k_a,k_b γ_a,γ_b Ps：k_i,γ_i自始自终都不会直接分享出去 定义k = k_a + k_b 定义γ = γ_a + γ_b 2、每两个人都进行两次MtA(Multiplicative-to-Additive)协议 2."><meta property="og:type" content="article"><meta property="og:url" content="https://wifiwang777.github.io/posts/%E9%97%A8%E9%99%90%E7%AD%BE%E5%90%8D%E6%96%B9%E6%A1%882tssthreshold-signature-sheme/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-02-19T12:06:28+00:00"><meta property="article:modified_time" content="2022-02-19T12:06:28+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="门限签名方案2——TSS(threshold-signature-sheme)"><meta name=twitter:description content="背景 目前市面上流行的门限椭圆曲线数字签名（Threshold ECDSA）方案是由Rosario Gennaro and Steven Goldfeder在2018年发布的论文（简称gg18）为理论基础实现的，本文主要描述了gg18在ECDSA中的大致流程。
链接 Multiparty Threshold ECDSA (GG18)
http://aandds.com/blog/multiparty-threshold-ecdsa.html
gg18.pdf gg20.pdf
TSS过程 密钥生成 假设现在有个T-N等于2-3的tss方案，参与者为a,b,c; 1、a,b,c分别各选择一个随机数为自己的秘密值,如，Sa = 1 ,Sb = 2, Sc = 3， 整体的秘密（私钥d）=Sa + Sb +Sc = 1 + 2 + 3 =6; 2、用各自选择的秘密值，再随机各生成一个(T-1)次的多项式，如： Fn_a = x + 1 Fn_b = 2x + 2 Fn_c = 3x + 3 3、将各自的秘密值分享给其他参与者 假设a的id为1，b的id为2，c的id为3，将各自的id分享给参与者 a，b，c使用自己的多项式方程将其他人的id带入其中 a: Fn_a(1) = 2 #a自己留存 Fn_a(2) = 3 #发送给b Fn_a(3) = 4 #发送给c b: Fn_b(1) = 4 #发送给a Fn_b(2) = 6 #b自己留存 Fn_b(3) = 8 #发送给c c: Fn_c(1) = 6 #发送给a Fn_c(2) = 9 #发送给b Fn_c(3) = 12 #c自己留存 4、a，b，c分别计算他们的Xi X_a = Fn_a(1) + Fn_b(1) + Fn_c(1) = 2 + 4 + 6 = 12 #a计算并保存 X_b = Fn_a(2) + Fn_b(2) + Fn_c(2) = 3 + 6 + 9 = 18 #b计算并保存 X_c = Fn_a(3) + Fn_b(3) + Fn_c(3) = 4 + 8 + 12 = 24 #c计算并保存 至此，私钥&#34;6&#34;已经通过2-3的方式分散到了a,b,c三个参与者中，也就是说，(1,12),(2,18),(3,24)这三个点， 其中任意两个点都可以通过拉格朗日插值算法，得到x=0处的值就是秘密值&#34;6&#34;。 此时a的碎片值就是&#34;12&#34; 此时b的碎片值就是&#34;18&#34; 此时c的碎片值就是&#34;24&#34; 那么公钥如何产生呢？ a,b,c分别计算Sa*G、Sb*G、Sc*G然后分享给其他人（不会泄漏各自的秘密值）， 最终每个人都能得到Sa*G、Sb*G、Sc*G。 然后计算Sa*G+Sb*G+Sc*G=(Sa+Sb+Sc)*G=d*G=Q,就能得到公钥了。 签名 思路 求r 现在a，b要进行签名 R(x,y)=k^-1 * G (mod n),r=x。 注: 1、此处k^-1表示为k对于n（椭圆曲线的阶）的取模逆元，即找到一个数z，令k*z ≡ 1 (mod n) ,k^-1 = z 2、此处的k的含义跟普通ECDSA签名算法里面的k并不是一个概念，但是能满足签名和验签公式，因为满足k*k^-1=1 引入一个变量γ，γ=∑γ_i R = k^-1 * γ * γ^-1 * G = (kγ)^-1 * γG = (kγ)^-1 * (γ_a +γ_b)G = (kγ)^-1 * (γ_a*G + γ_b*G) 每个参与者单独计算γi*G,这个可以公开，因为γi*G反推不出γi。 然后就是想个办法计算σ=k*γ了 求s s = k(m+dr) =(k_a + k_b)m + kdr =(k_a + k_b)m + ∂*r =(k_a + k_b)m + (∂_a + ∂_b)*r =(k_a*m + ∂_a*r) + (k_b*m + ∂_b*r) 引入变量∂，令k*d=∂=∑∂_i 签名步骤 由上面密钥生成的步骤可得，a的碎片x_a为12，b的碎片x_b为18。 它们是私钥&#34;6&#34;的(2,3)Feldman-VSS分享方案。 我们先它变为整体秘密&#34;6&#34;的2人additive sharing分享方案。 即要满足 d_a + d_b = 6 ，通过拉格朗日系数相乘方法可以求得： d_a = µ_a * x_a = [(0-2)/(1-2)] * x_a = 2 * x_a = 24 d_b = µ_b * x_b = [(0-1)/(2-1)] * x_b = -1 * x_b = -18 显然满足d_a + d_b = 24 - 18 = 6 1、a，b随机选择k_i、γ_i,如： k_a,k_b γ_a,γ_b Ps：k_i,γ_i自始自终都不会直接分享出去 定义k = k_a + k_b 定义γ = γ_a + γ_b 2、每两个人都进行两次MtA(Multiplicative-to-Additive)协议 2."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://wifiwang777.github.io/posts/"},{"@type":"ListItem","position":2,"name":"门限签名方案2——TSS(threshold-signature-sheme)","item":"https://wifiwang777.github.io/posts/%E9%97%A8%E9%99%90%E7%AD%BE%E5%90%8D%E6%96%B9%E6%A1%882tssthreshold-signature-sheme/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"门限签名方案2——TSS(threshold-signature-sheme)","name":"门限签名方案2——TSS(threshold-signature-sheme)","description":"背景 目前市面上流行的门限椭圆曲线数字签名（Threshold ECDSA）方案是由Rosario Gennaro and Steven Goldfeder在2018年发布的论文（简称gg18）为理论基础实现的，本文主要描述了gg18在ECDSA中的大致流程。\n链接 Multiparty Threshold ECDSA (GG18)\nhttp://aandds.com/blog/multiparty-threshold-ecdsa.html\ngg18.pdf gg20.pdf\nTSS过程 密钥生成 假设现在有个T-N等于2-3的tss方案，参与者为a,b,c; 1、a,b,c分别各选择一个随机数为自己的秘密值,如，Sa = 1 ,Sb = 2, Sc = 3， 整体的秘密（私钥d）=Sa + Sb +Sc = 1 + 2 + 3 =6; 2、用各自选择的秘密值，再随机各生成一个(T-1)次的多项式，如： Fn_a = x + 1 Fn_b = 2x + 2 Fn_c = 3x + 3 3、将各自的秘密值分享给其他参与者 假设a的id为1，b的id为2，c的id为3，将各自的id分享给参与者 a，b，c使用自己的多项式方程将其他人的id带入其中 a: Fn_a(1) = 2 #a自己留存 Fn_a(2) = 3 #发送给b Fn_a(3) = 4 #发送给c b: Fn_b(1) = 4 #发送给a Fn_b(2) = 6 #b自己留存 Fn_b(3) = 8 #发送给c c: Fn_c(1) = 6 #发送给a Fn_c(2) = 9 #发送给b Fn_c(3) = 12 #c自己留存 4、a，b，c分别计算他们的Xi X_a = Fn_a(1) + Fn_b(1) + Fn_c(1) = 2 + 4 + 6 = 12 #a计算并保存 X_b = Fn_a(2) + Fn_b(2) + Fn_c(2) = 3 + 6 + 9 = 18 #b计算并保存 X_c = Fn_a(3) + Fn_b(3) + Fn_c(3) = 4 + 8 + 12 = 24 #c计算并保存 至此，私钥\u0026#34;6\u0026#34;已经通过2-3的方式分散到了a,b,c三个参与者中，也就是说，(1,12),(2,18),(3,24)这三个点， 其中任意两个点都可以通过拉格朗日插值算法，得到x=0处的值就是秘密值\u0026#34;6\u0026#34;。 此时a的碎片值就是\u0026#34;12\u0026#34; 此时b的碎片值就是\u0026#34;18\u0026#34; 此时c的碎片值就是\u0026#34;24\u0026#34; 那么公钥如何产生呢？ a,b,c分别计算Sa*G、Sb*G、Sc*G然后分享给其他人（不会泄漏各自的秘密值）， 最终每个人都能得到Sa*G、Sb*G、Sc*G。 然后计算Sa*G+Sb*G+Sc*G=(Sa+Sb+Sc)*G=d*G=Q,就能得到公钥了。 签名 思路 求r 现在a，b要进行签名 R(x,y)=k^-1 * G (mod n),r=x。 注: 1、此处k^-1表示为k对于n（椭圆曲线的阶）的取模逆元，即找到一个数z，令k*z ≡ 1 (mod n) ,k^-1 = z 2、此处的k的含义跟普通ECDSA签名算法里面的k并不是一个概念，但是能满足签名和验签公式，因为满足k*k^-1=1 引入一个变量γ，γ=∑γ_i R = k^-1 * γ * γ^-1 * G = (kγ)^-1 * γG = (kγ)^-1 * (γ_a +γ_b)G = (kγ)^-1 * (γ_a*G + γ_b*G) 每个参与者单独计算γi*G,这个可以公开，因为γi*G反推不出γi。 然后就是想个办法计算σ=k*γ了 求s s = k(m+dr) =(k_a + k_b)m + kdr =(k_a + k_b)m + ∂*r =(k_a + k_b)m + (∂_a + ∂_b)*r =(k_a*m + ∂_a*r) + (k_b*m + ∂_b*r) 引入变量∂，令k*d=∂=∑∂_i 签名步骤 由上面密钥生成的步骤可得，a的碎片x_a为12，b的碎片x_b为18。 它们是私钥\u0026#34;6\u0026#34;的(2,3)Feldman-VSS分享方案。 我们先它变为整体秘密\u0026#34;6\u0026#34;的2人additive sharing分享方案。 即要满足 d_a + d_b = 6 ，通过拉格朗日系数相乘方法可以求得： d_a = µ_a * x_a = [(0-2)/(1-2)] * x_a = 2 * x_a = 24 d_b = µ_b * x_b = [(0-1)/(2-1)] * x_b = -1 * x_b = -18 显然满足d_a + d_b = 24 - 18 = 6 1、a，b随机选择k_i、γ_i,如： k_a,k_b γ_a,γ_b Ps：k_i,γ_i自始自终都不会直接分享出去 定义k = k_a + k_b 定义γ = γ_a + γ_b 2、每两个人都进行两次MtA(Multiplicative-to-Additive)协议 2.","keywords":[],"articleBody":"背景 目前市面上流行的门限椭圆曲线数字签名（Threshold ECDSA）方案是由Rosario Gennaro and Steven Goldfeder在2018年发布的论文（简称gg18）为理论基础实现的，本文主要描述了gg18在ECDSA中的大致流程。\n链接 Multiparty Threshold ECDSA (GG18)\nhttp://aandds.com/blog/multiparty-threshold-ecdsa.html\ngg18.pdf gg20.pdf\nTSS过程 密钥生成 假设现在有个T-N等于2-3的tss方案，参与者为a,b,c; 1、a,b,c分别各选择一个随机数为自己的秘密值,如，Sa = 1 ,Sb = 2, Sc = 3， 整体的秘密（私钥d）=Sa + Sb +Sc = 1 + 2 + 3 =6; 2、用各自选择的秘密值，再随机各生成一个(T-1)次的多项式，如： Fn_a = x + 1 Fn_b = 2x + 2 Fn_c = 3x + 3 3、将各自的秘密值分享给其他参与者 假设a的id为1，b的id为2，c的id为3，将各自的id分享给参与者 a，b，c使用自己的多项式方程将其他人的id带入其中 a: Fn_a(1) = 2 #a自己留存 Fn_a(2) = 3 #发送给b Fn_a(3) = 4 #发送给c b: Fn_b(1) = 4 #发送给a Fn_b(2) = 6 #b自己留存 Fn_b(3) = 8 #发送给c c: Fn_c(1) = 6 #发送给a Fn_c(2) = 9 #发送给b Fn_c(3) = 12 #c自己留存 4、a，b，c分别计算他们的Xi X_a = Fn_a(1) + Fn_b(1) + Fn_c(1) = 2 + 4 + 6 = 12 #a计算并保存 X_b = Fn_a(2) + Fn_b(2) + Fn_c(2) = 3 + 6 + 9 = 18 #b计算并保存 X_c = Fn_a(3) + Fn_b(3) + Fn_c(3) = 4 + 8 + 12 = 24 #c计算并保存 至此，私钥\"6\"已经通过2-3的方式分散到了a,b,c三个参与者中，也就是说，(1,12),(2,18),(3,24)这三个点， 其中任意两个点都可以通过拉格朗日插值算法，得到x=0处的值就是秘密值\"6\"。 此时a的碎片值就是\"12\" 此时b的碎片值就是\"18\" 此时c的碎片值就是\"24\" 那么公钥如何产生呢？ a,b,c分别计算Sa*G、Sb*G、Sc*G然后分享给其他人（不会泄漏各自的秘密值）， 最终每个人都能得到Sa*G、Sb*G、Sc*G。 然后计算Sa*G+Sb*G+Sc*G=(Sa+Sb+Sc)*G=d*G=Q,就能得到公钥了。 签名 思路 求r 现在a，b要进行签名 R(x,y)=k^-1 * G (mod n),r=x。 注: 1、此处k^-1表示为k对于n（椭圆曲线的阶）的取模逆元，即找到一个数z，令k*z ≡ 1 (mod n) ,k^-1 = z 2、此处的k的含义跟普通ECDSA签名算法里面的k并不是一个概念，但是能满足签名和验签公式，因为满足k*k^-1=1 引入一个变量γ，γ=∑γ_i R = k^-1 * γ * γ^-1 * G = (kγ)^-1 * γG = (kγ)^-1 * (γ_a +γ_b)G = (kγ)^-1 * (γ_a*G + γ_b*G) 每个参与者单独计算γi*G,这个可以公开，因为γi*G反推不出γi。 然后就是想个办法计算σ=k*γ了 求s s = k(m+dr) =(k_a + k_b)m + kdr =(k_a + k_b)m + ∂*r =(k_a + k_b)m + (∂_a + ∂_b)*r =(k_a*m + ∂_a*r) + (k_b*m + ∂_b*r) 引入变量∂，令k*d=∂=∑∂_i 签名步骤 由上面密钥生成的步骤可得，a的碎片x_a为12，b的碎片x_b为18。 它们是私钥\"6\"的(2,3)Feldman-VSS分享方案。 我们先它变为整体秘密\"6\"的2人additive sharing分享方案。 即要满足 d_a + d_b = 6 ，通过拉格朗日系数相乘方法可以求得： d_a = µ_a * x_a = [(0-2)/(1-2)] * x_a = 2 * x_a = 24 d_b = µ_b * x_b = [(0-1)/(2-1)] * x_b = -1 * x_b = -18 显然满足d_a + d_b = 24 - 18 = 6 1、a，b随机选择k_i、γ_i,如： k_a,k_b γ_a,γ_b Ps：k_i,γ_i自始自终都不会直接分享出去 定义k = k_a + k_b 定义γ = γ_a + γ_b 2、每两个人都进行两次MtA(Multiplicative-to-Additive)协议 2.1、第一次MtA协议，Pi,Pj对k_i,γ_j使用MtA(i!=j)， 把Pi的结果记为α_ij，Pj得到的结果记为ß_ij,也就是满足： k_i*γ_j = α_ij + ß_ij 例如： k_a * γ_b = α_{ab} + ß_{ab} k_b * γ_a = α_{ba} + ß_{ba} 此时a手中可知的数字：k_a、γ_a、α_{ab}、ß_{ba} 此时b手中可知的数字：k_b、γ_b、ß_{ab}、α_{ba} 定义 σi = k_i*γ_i + ∑α_ij + ∑ß_ji,则： σ_a = k_a*Ya + α_{ab} + ß_{ba} σ_b = k_b*Yb + α_{ba} + ß_{ab} 可以推出k*γ = (∑k_i) * (∑γ_i) = ∑σi = σ，推导过程： k*γ = (k_a + k_b) * (Ya + Yb) = k_a*Ya + k_a*Yb + k_b*Ya + k_b*Yb = k_a*Ya + α_{ab} + ß_{ab} + α_{ba} + ß_{ba} + k_b*Yb = σ_a + σ_b = ∑σ_i 2.2、第二次MtA协议，Pi,Pj对k_i,d_j使用MtA(i!=j)， 把Pi的结果记为µ_ij，Pj得到的结果记为v_ij,也就是满足： k_i*d_j = µ_ij + v_ij 例如： k_a * d_b = µ_{ab} + v_{ab} k_b * d_a = µ_{ba} + v_{ba} 此时a手中可知的数字：k_a、d_a、µ_{ab}、v_{ba} 此时b手中可知的数字：k_b、γ_b、v_{ab}、µ_{ba} 定义 ∂_i = k_i*d_i + ∑µ_ij + ∑v_ji,则： ∂_a = k_a*Wa + µ_{ab} + v_{ba} ∂_b = k_b*Wb + µ_{ba} + v_{ab} 可以推出k*d = (∑k_i) * (∑d_i) = ∑∂_i = ∂，推导过程：同2.1 3、a/b公开σ_i，这样所有参与者都能计算出k*γ=σ。 4、a/b公开γ_i*G,通过上面的思路，这样就求得r了。 5、在第二次MtA协议后，a/b各自计算出了∂_i,从而得到s_i=k_i*m + ∂_i*r,于是求得s=∑s_i了。 一些知识点 paillier同态加密 引用 https://www.cnblogs.com/sssssaylf/p/12398133.html\n算法描述: 重要作用(加法同态) Encrypt(m1+m2) = Encrypt(m1) * Encrypt(m2) MtA(Multiplicative-to-Additive)协议 假设Alice有个秘密值a，Bob有个秘密值b，则可以在Alice不泄漏a、Bob不泄露b的情况下 ，Alice、Bob分别得到另一个秘密值α、ß，满足： ab = α + ß 具体过程如下\n","wordCount":"465","inLanguage":"en","datePublished":"2022-02-19T12:06:28Z","dateModified":"2022-02-19T12:06:28Z","mainEntityOfPage":{"@type":"WebPage","@id":"https://wifiwang777.github.io/posts/%E9%97%A8%E9%99%90%E7%AD%BE%E5%90%8D%E6%96%B9%E6%A1%882tssthreshold-signature-sheme/"},"publisher":{"@type":"Organization","name":"伍伍爹","logo":{"@type":"ImageObject","url":"https://wifiwang777.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://wifiwang777.github.io/ accesskey=h title="伍伍爹 (Alt + H)">伍伍爹</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">门限签名方案2——TSS(threshold-signature-sheme)</h1><div class=post-meta><span title='2022-02-19 12:06:28 +0000 UTC'>February 19, 2022</span></div></header><div class=post-content><h3 id=背景>背景<a hidden class=anchor aria-hidden=true href=#背景>#</a></h3><p>目前市面上流行的门限椭圆曲线数字签名（Threshold ECDSA）方案是由Rosario Gennaro and Steven
Goldfeder在2018年发布的论文（简称gg18）为理论基础实现的，本文主要描述了gg18在ECDSA中的大致流程。</p><h5 id=链接>链接<a hidden class=anchor aria-hidden=true href=#链接>#</a></h5><p>Multiparty Threshold ECDSA (GG18)</p><p><a href=http://aandds.com/blog/multiparty-threshold-ecdsa.html>http://aandds.com/blog/multiparty-threshold-ecdsa.html</a></p><p><a href=/%E9%97%A8%E9%99%90%E7%AD%BE%E5%90%8D%E6%96%B9%E6%A1%882%E2%80%94%E2%80%94TSS(threshold-signature-sheme)/gg18.pdf>gg18.pdf</a>
<a href=/%E9%97%A8%E9%99%90%E7%AD%BE%E5%90%8D%E6%96%B9%E6%A1%882%E2%80%94%E2%80%94TSS(threshold-signature-sheme)/gg20.pdf>gg20.pdf</a></p><h3 id=tss过程>TSS过程<a hidden class=anchor aria-hidden=true href=#tss过程>#</a></h3><ul><li><h3 id=密钥生成>密钥生成<a hidden class=anchor aria-hidden=true href=#密钥生成>#</a></h3></li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>假设现在有个T-N等于2-3的tss方案，参与者为a,b,c;
</span></span><span style=display:flex><span>1、a,b,c分别各选择一个随机数为自己的秘密值,如，Sa = 1 ,Sb = 2, Sc = 3，
</span></span><span style=display:flex><span>整体的秘密（私钥d）=Sa + Sb +Sc = 1 + 2 + 3 =6;
</span></span><span style=display:flex><span>2、用各自选择的秘密值，再随机各生成一个(T-1)次的多项式，如：
</span></span><span style=display:flex><span>Fn_a = x + 1
</span></span><span style=display:flex><span>Fn_b = 2x + 2
</span></span><span style=display:flex><span>Fn_c = 3x + 3
</span></span><span style=display:flex><span>3、将各自的秘密值分享给其他参与者
</span></span><span style=display:flex><span>假设a的id为1，b的id为2，c的id为3，将各自的id分享给参与者
</span></span><span style=display:flex><span>a，b，c使用自己的多项式方程将其他人的id带入其中
</span></span><span style=display:flex><span>a:  
</span></span><span style=display:flex><span>    Fn_a(1) = 2 #a自己留存
</span></span><span style=display:flex><span>    Fn_a(2) = 3 #发送给b
</span></span><span style=display:flex><span>    Fn_a(3) = 4 #发送给c
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>b:  
</span></span><span style=display:flex><span>    Fn_b(1) = 4 #发送给a
</span></span><span style=display:flex><span>    Fn_b(2) = 6 #b自己留存
</span></span><span style=display:flex><span>    Fn_b(3) = 8 #发送给c
</span></span><span style=display:flex><span>c:  
</span></span><span style=display:flex><span>    Fn_c(1) = 6  #发送给a
</span></span><span style=display:flex><span>    Fn_c(2) = 9  #发送给b
</span></span><span style=display:flex><span>    Fn_c(3) = 12 #c自己留存
</span></span><span style=display:flex><span>4、a，b，c分别计算他们的Xi
</span></span><span style=display:flex><span>X_a = Fn_a(1) + Fn_b(1) + Fn_c(1) = 2 + 4 + 6 = 12  #a计算并保存
</span></span><span style=display:flex><span>X_b = Fn_a(2) + Fn_b(2) + Fn_c(2) = 3 + 6 + 9 = 18  #b计算并保存
</span></span><span style=display:flex><span>X_c = Fn_a(3) + Fn_b(3) + Fn_c(3) = 4 + 8 + 12 = 24 #c计算并保存
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>至此，私钥&#34;6&#34;已经通过2-3的方式分散到了a,b,c三个参与者中，也就是说，(1,12),(2,18),(3,24)这三个点，
</span></span><span style=display:flex><span>其中任意两个点都可以通过拉格朗日插值算法，得到x=0处的值就是秘密值&#34;6&#34;。
</span></span><span style=display:flex><span>此时a的碎片值就是&#34;12&#34;
</span></span><span style=display:flex><span>此时b的碎片值就是&#34;18&#34;
</span></span><span style=display:flex><span>此时c的碎片值就是&#34;24&#34;
</span></span></code></pre></div><p><img loading=lazy src=/%e9%97%a8%e9%99%90%e7%ad%be%e5%90%8d%e6%96%b9%e6%a1%882%e2%80%94%e2%80%94TSS%28threshold-signature-sheme%29/%e6%8b%89%e6%a0%bc%e6%9c%97%e6%97%a5%e6%8f%92%e5%80%bc.png alt></p><h4 id=那么公钥如何产生呢>那么公钥如何产生呢？<a hidden class=anchor aria-hidden=true href=#那么公钥如何产生呢>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>  a,b,c分别计算Sa*G、Sb*G、Sc*G然后分享给其他人（不会泄漏各自的秘密值），
</span></span><span style=display:flex><span>最终每个人都能得到Sa*G、Sb*G、Sc*G。
</span></span><span style=display:flex><span>  然后计算Sa*G+Sb*G+Sc*G=(Sa+Sb+Sc)*G=d*G=Q,就能得到公钥了。
</span></span></code></pre></div><ul><li><h3 id=签名>签名<a hidden class=anchor aria-hidden=true href=#签名>#</a></h3></li></ul><h4 id=思路>思路<a hidden class=anchor aria-hidden=true href=#思路>#</a></h4><h5 id=求r>求r<a hidden class=anchor aria-hidden=true href=#求r>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>现在a，b要进行签名
</span></span><span style=display:flex><span>R(x,y)=k^-1 * G (mod n),r=x。
</span></span><span style=display:flex><span>注: 1、此处k^-1表示为k对于n（椭圆曲线的阶）的取模逆元，即找到一个数z，令k*z ≡ 1 (mod n) ,k^-1 = z
</span></span><span style=display:flex><span>    2、此处的k的含义跟普通ECDSA签名算法里面的k并不是一个概念，但是能满足签名和验签公式，因为满足k*k^-1=1
</span></span><span style=display:flex><span>引入一个变量γ，γ=∑γ_i
</span></span><span style=display:flex><span>R = k^-1 * γ * γ^-1 * G = (kγ)^-1 * γG = (kγ)^-1 * (γ_a +γ_b)G = (kγ)^-1 * (γ_a*G + γ_b*G)
</span></span><span style=display:flex><span>每个参与者单独计算γi*G,这个可以公开，因为γi*G反推不出γi。
</span></span><span style=display:flex><span>然后就是想个办法计算σ=k*γ了
</span></span></code></pre></div><h5 id=求s>求s<a hidden class=anchor aria-hidden=true href=#求s>#</a></h5><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>s = k(m+dr)
</span></span><span style=display:flex><span>  =(k_a + k_b)m + kdr
</span></span><span style=display:flex><span>  =(k_a + k_b)m + ∂*r
</span></span><span style=display:flex><span>  =(k_a + k_b)m + (∂_a + ∂_b)*r
</span></span><span style=display:flex><span>  =(k_a*m + ∂_a*r) + (k_b*m + ∂_b*r)
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span>引入变量∂，令k*d=∂=∑∂_i
</span></span></code></pre></div><h4 id=签名步骤>签名步骤<a hidden class=anchor aria-hidden=true href=#签名步骤>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>由上面密钥生成的步骤可得，a的碎片x_a为12，b的碎片x_b为18。
</span></span><span style=display:flex><span>它们是私钥&#34;6&#34;的(2,3)Feldman-VSS分享方案。
</span></span><span style=display:flex><span>我们先它变为整体秘密&#34;6&#34;的2人additive sharing分享方案。
</span></span><span style=display:flex><span>即要满足 d_a + d_b = 6  ，通过拉格朗日系数相乘方法可以求得：
</span></span><span style=display:flex><span>d_a = µ_a * x_a = [(0-2)/(1-2)] * x_a = 2 * x_a = 24
</span></span><span style=display:flex><span>d_b = µ_b * x_b = [(0-1)/(2-1)] * x_b = -1 * x_b = -18
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>显然满足d_a + d_b = 24 - 18 = 6
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>1、a，b随机选择k_i、γ_i,如：
</span></span><span style=display:flex><span>k_a,k_b
</span></span><span style=display:flex><span>γ_a,γ_b
</span></span><span style=display:flex><span>Ps：k_i,γ_i自始自终都不会直接分享出去
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>定义k = k_a + k_b 
</span></span><span style=display:flex><span>定义γ = γ_a + γ_b
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>2、每两个人都进行两次MtA(Multiplicative-to-Additive)协议
</span></span><span style=display:flex><span>2.1、第一次MtA协议，Pi,Pj对k_i,γ_j使用MtA(i!=j)，
</span></span><span style=display:flex><span>把Pi的结果记为α_ij，Pj得到的结果记为ß_ij,也就是满足：
</span></span><span style=display:flex><span>k_i*γ_j = α_ij + ß_ij
</span></span><span style=display:flex><span>例如：
</span></span><span style=display:flex><span>k_a * γ_b = α_{ab} + ß_{ab}
</span></span><span style=display:flex><span>k_b * γ_a = α_{ba} + ß_{ba}
</span></span><span style=display:flex><span>此时a手中可知的数字：k_a、γ_a、α_{ab}、ß_{ba}
</span></span><span style=display:flex><span>此时b手中可知的数字：k_b、γ_b、ß_{ab}、α_{ba}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>定义 σi = k_i*γ_i + ∑α_ij + ∑ß_ji,则：
</span></span><span style=display:flex><span>σ_a = k_a*Ya + α_{ab} + ß_{ba}
</span></span><span style=display:flex><span>σ_b = k_b*Yb + α_{ba} + ß_{ab}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>可以推出k*γ = (∑k_i) * (∑γ_i) = ∑σi = σ，推导过程：
</span></span><span style=display:flex><span>k*γ = (k_a + k_b) * (Ya + Yb)
</span></span><span style=display:flex><span>    = k_a*Ya + k_a*Yb + k_b*Ya + k_b*Yb  
</span></span><span style=display:flex><span>    = k_a*Ya + α_{ab} + ß_{ab} + α_{ba} + ß_{ba} + k_b*Yb  
</span></span><span style=display:flex><span>    = σ_a + σ_b
</span></span><span style=display:flex><span>    = ∑σ_i
</span></span><span style=display:flex><span>    
</span></span><span style=display:flex><span>2.2、第二次MtA协议，Pi,Pj对k_i,d_j使用MtA(i!=j)，
</span></span><span style=display:flex><span>把Pi的结果记为µ_ij，Pj得到的结果记为v_ij,也就是满足：
</span></span><span style=display:flex><span>k_i*d_j = µ_ij + v_ij
</span></span><span style=display:flex><span>例如：
</span></span><span style=display:flex><span>k_a * d_b = µ_{ab} + v_{ab}
</span></span><span style=display:flex><span>k_b * d_a = µ_{ba} + v_{ba}
</span></span><span style=display:flex><span>此时a手中可知的数字：k_a、d_a、µ_{ab}、v_{ba}
</span></span><span style=display:flex><span>此时b手中可知的数字：k_b、γ_b、v_{ab}、µ_{ba}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>定义 ∂_i = k_i*d_i + ∑µ_ij + ∑v_ji,则：
</span></span><span style=display:flex><span>∂_a = k_a*Wa + µ_{ab} + v_{ba}
</span></span><span style=display:flex><span>∂_b = k_b*Wb + µ_{ba} + v_{ab}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>可以推出k*d = (∑k_i) * (∑d_i) = ∑∂_i = ∂，推导过程：同2.1
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>3、a/b公开σ_i，这样所有参与者都能计算出k*γ=σ。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>4、a/b公开γ_i*G,通过上面的思路，这样就求得r了。
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>5、在第二次MtA协议后，a/b各自计算出了∂_i,从而得到s_i=k_i*m + ∂_i*r,于是求得s=∑s_i了。
</span></span></code></pre></div><h3 id=一些知识点>一些知识点<a hidden class=anchor aria-hidden=true href=#一些知识点>#</a></h3><h4 id=paillier同态加密>paillier同态加密<a hidden class=anchor aria-hidden=true href=#paillier同态加密>#</a></h4><p>引用 <a href=https://www.cnblogs.com/sssssaylf/p/12398133.html>https://www.cnblogs.com/sssssaylf/p/12398133.html</a></p><h5 id=算法描述>算法描述:<a hidden class=anchor aria-hidden=true href=#算法描述>#</a></h5><p><img loading=lazy src=/%e9%97%a8%e9%99%90%e7%ad%be%e5%90%8d%e6%96%b9%e6%a1%882%e2%80%94%e2%80%94TSS%28threshold-signature-sheme%29/paillier%e5%90%8c%e6%80%81%e5%8a%a0%e5%af%86.png alt></p><h6 id=重要作用加法同态>重要作用(加法同态)<a hidden class=anchor aria-hidden=true href=#重要作用加法同态>#</a></h6><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>Encrypt(m1+m2) = Encrypt(m1) * Encrypt(m2)
</span></span></code></pre></div><h5 id=mtamultiplicative-to-additive协议>MtA(Multiplicative-to-Additive)协议<a hidden class=anchor aria-hidden=true href=#mtamultiplicative-to-additive协议>#</a></h5><p>假设Alice有个秘密值a，Bob有个秘密值b，则可以在Alice不泄漏a、Bob不泄露b的情况下 ，Alice、Bob分别得到另一个秘密值α、ß，满足： ab = α + ß 具体过程如下</p><p><img loading=lazy src=/%e9%97%a8%e9%99%90%e7%ad%be%e5%90%8d%e6%96%b9%e6%a1%882%e2%80%94%e2%80%94TSS%28threshold-signature-sheme%29/MtA%e5%8d%8f%e8%ae%ae.png alt></p></div><footer class=post-footer><ul class=post-tags></ul></footer><script src=https://giscus.app/client.js data-repo=wifi66666/wifi66666.github.io data-repo-id=R_kgDOK8jBbw data-category=Announcements data-category-id=DIC_kwDOK8jBb84Cb7X4 data-mapping=pathname data-strict=0 data-reactions-enabled=1 data-emit-metadata=0 data-input-position=bottom data-theme=preferred_color_scheme data-lang=zh-CN crossorigin=anonymous async></script></article></main><footer class=footer><span>&copy; 2024 <a href=https://wifiwang777.github.io/>伍伍爹</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>